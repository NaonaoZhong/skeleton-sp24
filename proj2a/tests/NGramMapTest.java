import ngrams.NGramMap;
import ngrams.TimeSeries;

import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import static utils.Utils.*;
import static com.google.common.truth.Truth.assertThat;

/** Unit Tests for the NGramMap class.
 *  @author Josh Hug
 */
public class NGramMapTest {
    @Test
    public void testCountHistory() {
        NGramMap ngm = new NGramMap(SHORT_WORDS_FILE, TOTAL_COUNTS_FILE);
        List<Integer> expectedYears = new ArrayList<>
                (Arrays.asList(2005, 2006, 2007, 2008));
        List<Double> expectedCounts = new ArrayList<>
                (Arrays.asList(646179.0, 677820.0, 697645.0, 795265.0));

        TimeSeries request2005to2008 = ngm.countHistory("request");
        assertThat(request2005to2008.years()).isEqualTo(expectedYears);

        for (int i = 0; i < expectedCounts.size(); i += 1) {
            assertThat(request2005to2008.data().get(i)).isWithin(1E-10).of(expectedCounts.get(i));
        }

        expectedYears = new ArrayList<>
                (Arrays.asList(2006, 2007));
        expectedCounts = new ArrayList<>
                (Arrays.asList(677820.0, 697645.0));

        TimeSeries request2006to2007 = ngm.countHistory("request", 2006, 2007);

        assertThat(request2006to2007.years()).isEqualTo(expectedYears);

        for (int i = 0; i < expectedCounts.size(); i += 1) {
            assertThat(request2006to2007.data().get(i)).isWithin(1E-10).of(expectedCounts.get(i));
        }
    }

    @Test
    public void testOnLargeFile() {
        // creates an NGramMap from a large dataset
        NGramMap ngm = new NGramMap(TOP_14337_WORDS_FILE,
                TOTAL_COUNTS_FILE);

        // returns the count of the number of occurrences of fish per year between 1850 and 1933.
        TimeSeries fishCount = ngm.countHistory("fish", 1850, 1933);
        assertThat(fishCount.get(1865)).isWithin(1E-10).of(136497.0);
        assertThat(fishCount.get(1922)).isWithin(1E-10).of(444924.0);

        TimeSeries totalCounts = ngm.totalCountHistory();
        assertThat(totalCounts.get(1865)).isWithin(1E-10).of(2563919231.0);

        // returns the relative weight of the word fish in each year between 1850 and 1933.
        TimeSeries fishWeight = ngm.weightHistory("fish", 1850, 1933);
        assertThat(fishWeight.get(1865)).isWithin(1E-7).of(136497.0/2563919231.0);

        TimeSeries dogCount = ngm.countHistory("dog", 1850, 1876);
        assertThat(dogCount.get(1865)).isWithin(1E-10).of(75819.0);

        List<String> fishAndDog = new ArrayList<>();
        fishAndDog.add("fish");
        fishAndDog.add("dog");
        TimeSeries fishPlusDogWeight = ngm.summedWeightHistory(fishAndDog, 1865, 1866);

        double expectedFishPlusDogWeight1865 = (136497.0 + 75819.0) / 2563919231.0;
        assertThat(fishPlusDogWeight.get(1865)).isWithin(1E-10).of(expectedFishPlusDogWeight1865);
    }

    /**
     * tests below are generated by AI
     */
    @Test
    void testTotalCountHistoryDefensiveCopy() {
        // 1. 初始化 NGramMap 并获取原始总计数
        NGramMap ngm = new NGramMap(SHORT_WORDS_FILE, TOTAL_COUNTS_FILE);
        TimeSeries originalTotal = ngm.totalCountHistory();

        // 选择一个已知存在的年份（以 2005 为例，假设数据中存在该年份）
        int testYear = 2005;
        assertThat(originalTotal.containsKey(testYear)).isTrue(); // 确保测试年份存在

        // 记录原始数据的关键特征：年份值和集合大小
        double originalValue = originalTotal.get(testYear);
        int originalSize = originalTotal.size();

        // 2. 获取副本并进行修改（篡改值 + 添加新年份）
        TimeSeries totalCopy = ngm.totalCountHistory();
        totalCopy.put(testYear, 0.0); // 修改已有年份的值
        int newYear = 2023;
        totalCopy.put(newYear, 999999.0); // 添加新年份

        // 3. 验证原 NGramMap 的总计数未受影响
        TimeSeries totalAfterModification = ngm.totalCountHistory();

        // 3.1 原始年份的值未被篡改
        assertThat(totalAfterModification.get(testYear)).isEqualTo(originalValue);

        // 3.2 原集合大小未变（未添加新年份）
        assertThat(totalAfterModification.size()).isEqualTo(originalSize);

        // 3.3 新添加的年份不存在于原数据中
        assertThat(totalAfterModification.containsKey(newYear)).isFalse();

        // 4. 验证副本的修改不会反向影响原数据（进一步确认独立性）
        // （如果原数据内部被修改，副本也不应受影响，但此处重点是副本修改不影响原数据）
        assertThat(totalCopy.get(testYear)).isNotEqualTo(originalValue); // 副本已被修改
        assertThat(totalCopy.size()).isNotEqualTo(originalSize); // 副本大小已变
    }
}  